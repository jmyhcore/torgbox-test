Первым делом нужно избавиться от лишних и специальных символов(`«»"'`).
Сразу же извлекаем и убираем из исходной строки таймзону, это даст более гибкий доступ работе с регулярками.

Парсим все возможные варианты расположения `dd/mm/yyyy` в строке, включая текстовые месяца.  
Сюда же и распарсятся ISO-подобные строки, следовательно им не нужны отдельные обработчики.  
Чтобы сократить количество вызовов регулярок, можно добавить "разные" разделители между днями, месяцами и годами (например, в одном случае даты могут быть через точку, в другом - через слэш, а в третьем - тире).  

Далее необходимо проверить, что "месяц" записан числом. Если он указан словом, то, через обращение к словарю, находим его номер (не индекс, это важно для конструктора класса `Date()`).  


Ищем букву "*T*" в строке. Лучше сделать более комплексную проверку, включение одной случайной буквы вполне возможны. но задача этого не требует, поэтому этот пункт я опустил и оставил простую проверку "в лоб".  

**Если буква "*T*" найдена**, пытаемся выдернуть из строки параметры времени. если какой-то из параметров не задан - устанавливаем по умолчанию, в ноль.  
**Если буква "*T*" не найдена**, значит в исходной строке либо времени нет вообще, либо оно задано отдельно (не по стандарту ISO). Поскольку секунд и миллисекунд там нет, задаем их нулями. Далее пытаемся вытянуть часы и минуты, если найдено - задаем, в противном случае выставляем нули.

В конце создаем объект класса `Date`, через new `Date(Date.UTC())`, что даст нам больше контроля над таймзонами. В результате у нас всегда будет получаться время по гринвичу, с постфиксом "Z".  
После этого преобразовываем результат в строку, это требование к возвращаемому типу функции.
Если входные данные содержали таймзону, убираем "Z" с конца и указываем эту таймзону вручную.

